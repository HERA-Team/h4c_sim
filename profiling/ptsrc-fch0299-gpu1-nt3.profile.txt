Timer unit: 1e-06 s

Total time: 14.0239 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/hera_sim/visibilities/vis_cpu.py
Function: simulate at line 291

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   291                                               def simulate(self, data_model):
   292                                                   """
   293                                                   Calls :func:vis_cpu to perform the visibility calculation.
   294                                           
   295                                                   Returns
   296                                                   -------
   297                                                   array_like of self._complex_dtype
   298                                                       Visibilities. Shape=self.uvdata.data_array.shape.
   299                                                   """
   300         1         13.0     13.0      0.0          polarized = self._check_if_polarized(data_model)
   301         1        156.0    156.0      0.0          feed = self.get_feed(data_model.uvdata)
   302                                           
   303                                                   # Setup MPI info if enabled
   304         1          2.0      2.0      0.0          if self.mpi_comm is not None:
   305                                                       myid = self.mpi_comm.Get_rank()
   306                                                       nproc = self.mpi_comm.Get_size()
   307                                           
   308         1          2.0      2.0      0.0          if self.correct_source_positions:
   309                                                       # TODO: check if this is the right time to be using...
   310         2     194265.0  97132.5      1.4              ra, dec = self.correct_point_source_pos(
   311         1        338.0    338.0      0.0                  data_model, obstime=Time(data_model.uvdata.time_array[0], format="jd")
   312                                                       )
   313                                                   else:
   314                                                       ra, dec = data_model.sky_model.ra, data_model.sky_model.dec
   315                                           
   316         1      15870.0  15870.0      0.1          crd_eq = convs.point_source_crd_eq(ra, dec)
   317                                           
   318                                                   # Convert equatorial to topocentric coords
   319         1        145.0    145.0      0.0          eq2tops = self.get_eq2tops(data_model.uvdata, data_model.lsts)
   320                                           
   321                                                   # The following are antenna positions in the order that they are
   322                                                   # in the uvdata.data_array
   323         1       1647.0   1647.0      0.0          active_antpos, ant_list = data_model.uvdata.get_ENU_antpos(pick_data_ants=True)
   324                                           
   325                                                   # Get pixelized beams if required
   326                                           
   327         2         28.0     14.0      0.0          beam_list = [
   328                                                       convs.prepare_beam(
   329                                                           beam,
   330                                                           polarized=polarized,
   331                                                           use_feed=feed,
   332                                                       )
   333         1          6.0      6.0      0.0              for beam in data_model.beams
   334                                                   ]
   335         2         15.0      7.5      0.0          beam_ids = np.array(
   336         2        668.0    334.0      0.0              [
   337                                                           data_model.beam_ids[nm]
   338         2          4.0      2.0      0.0                  for i, nm in zip(
   339         1          5.0      5.0      0.0                      data_model.uvdata.antenna_numbers, data_model.uvdata.antenna_names
   340                                                           )
   341                                                           if i in ant_list
   342                                                       ]
   343                                                   )
   344                                           
   345                                                   # Get all the polarizations required to be simulated.
   346         2        534.0    267.0      0.0          req_pols = self._get_req_pols(
   347         1          5.0      5.0      0.0              data_model.uvdata, data_model.beams[0], polarized=polarized
   348                                                   )
   349                                           
   350                                                   # Empty visibility array
   351         1        126.0    126.0      0.0          visfull = np.zeros_like(data_model.uvdata.data_array, dtype=self._complex_dtype)
   352                                           
   353         2         13.0      6.5      0.0          for i, freq in enumerate(data_model.freqs):
   354                                                       # Divide tasks between MPI workers if needed
   355         1          2.0      2.0      0.0              if self.mpi_comm is not None and i % nproc != myid:
   356                                                           continue
   357                                           
   358                                                       # Call vis_cpu function to simulate visibilities
   359         2   10838903.0 5419451.5     77.3              vis = self._vis_cpu(
   360         1          1.0      1.0      0.0                  antpos=active_antpos,
   361         1          1.0      1.0      0.0                  freq=freq,
   362         1          2.0      2.0      0.0                  eq2tops=eq2tops,
   363         1          2.0      2.0      0.0                  crd_eq=crd_eq,
   364         1        375.0    375.0      0.0                  I_sky=data_model.sky_model.stokes[0, i].to("Jy").value,
   365         1          2.0      2.0      0.0                  beam_list=beam_list,
   366         1          1.0      1.0      0.0                  beam_idx=beam_ids,
   367         1          3.0      3.0      0.0                  precision=self._precision,
   368         1          1.0      1.0      0.0                  polarized=polarized,
   369                                                       )
   370                                           
   371         2    2970764.0 1485382.0     21.2              self._reorder_vis(
   372         1          5.0      5.0      0.0                  req_pols, data_model.uvdata, visfull[:, 0, i], vis, ant_list, polarized
   373                                                       )
   374                                           
   375                                                   # Reduce visfull array if in MPI mode
   376         1          2.0      2.0      0.0          if self.mpi_comm is not None:
   377                                                       visfull = self._reduce_mpi(visfull, myid)
   378                                           
   379         1          2.0      2.0      0.0          return visfull

Total time: 6.68089 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/pyuvdata/uvbeam/uvbeam.py
Function: interp at line 1611

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1611                                               def interp(
  1612                                                   self,
  1613                                                   az_array=None,
  1614                                                   za_array=None,
  1615                                                   az_za_grid=False,
  1616                                                   healpix_nside=None,
  1617                                                   healpix_inds=None,
  1618                                                   freq_array=None,
  1619                                                   freq_interp_tol=1.0,
  1620                                                   polarizations=None,
  1621                                                   return_bandpass=False,
  1622                                                   reuse_spline=False,
  1623                                                   spline_opts=None,
  1624                                                   new_object=False,
  1625                                                   run_check=True,
  1626                                                   check_extra=True,
  1627                                                   run_check_acceptability=True,
  1628                                                   check_azza_domain: bool = True,
  1629                                               ):
  1630                                                   """
  1631                                                   Interpolate beam to given frequency, az & za locations or Healpix pixel centers.
  1632                                           
  1633                                                   Parameters
  1634                                                   ----------
  1635                                                   az_array : array_like of floats, optional
  1636                                                       Azimuth values to interpolate to in radians, either specifying the
  1637                                                       azimuth positions for every interpolation point or specifying the
  1638                                                       azimuth vector for a meshgrid if az_za_grid is True.
  1639                                                   za_array : array_like of floats, optional
  1640                                                       Zenith values to interpolate to in radians, either specifying the
  1641                                                       zenith positions for every interpolation point or specifying the
  1642                                                       zenith vector for a meshgrid if az_za_grid is True.
  1643                                                   az_za_grid : bool
  1644                                                       Option to treat the `az_array` and `za_array` as the input vectors
  1645                                                       for points on a mesh grid.
  1646                                                   healpix_nside : int, optional
  1647                                                       HEALPix nside parameter if interpolating to HEALPix pixels.
  1648                                                   healpix_inds : array_like of int, optional
  1649                                                       HEALPix indices to interpolate to. Defaults to all indices in the
  1650                                                       map if `healpix_nside` is set and `az_array` and `za_array` are None.
  1651                                                   freq_array : array_like of floats, optional
  1652                                                       Frequency values to interpolate to.
  1653                                                   freq_interp_tol : float
  1654                                                       Frequency distance tolerance [Hz] of nearest neighbors.
  1655                                                       If *all* elements in freq_array have nearest neighbor distances within
  1656                                                       the specified tolerance then return the beam at each nearest neighbor,
  1657                                                       otherwise interpolate the beam.
  1658                                                   polarizations : list of str
  1659                                                       polarizations to interpolate if beam_type is 'power'.
  1660                                                       Default is all polarizations in self.polarization_array.
  1661                                                   new_object : bool
  1662                                                       Option to return a new UVBeam object with the interpolated data,
  1663                                                       if possible. Note that this is only possible for Healpix pixels or
  1664                                                       if az_za_grid is True and `az_array` and `za_array` are evenly spaced
  1665                                                       or for frequency only interpolation.
  1666                                                   reuse_spline : bool
  1667                                                       Save the interpolation functions for reuse. Only applies for
  1668                                                       `az_za_simple` interpolation.
  1669                                                   spline_opts : dict
  1670                                                       Provide options to numpy.RectBivariateSpline. This includes spline
  1671                                                       order parameters `kx` and `ky`, and smoothing parameter `s`.
  1672                                                       Only applies for `az_za_simple` interpolation.
  1673                                                   run_check : bool
  1674                                                       Only used if new_object is True. Option to check for the existence
  1675                                                       and proper shapes of required parameters on the new object.
  1676                                                   check_extra : bool
  1677                                                       Only used if new_object is True. Option to check optional parameters
  1678                                                       as well as required ones on the new object.
  1679                                                   run_check_acceptability : bool
  1680                                                       Only used if new_object is True. Option to check acceptable range
  1681                                                       of the values of required parameters on the new object.
  1682                                                   check_azza_domain : bool
  1683                                                       Whether to check the domain of az/za to ensure that they are covered by the
  1684                                                       intrinsic data array. Checking them can be quite computationally expensive.
  1685                                                       Conversely, if the passed az/za are outside of the domain, they will be
  1686                                                       silently extrapolated and the behavior is not well-defined.
  1687                                           
  1688                                                   Returns
  1689                                                   -------
  1690                                                   array_like of float or complex or a UVBeam object
  1691                                                       Either an array of interpolated values or a UVBeam object if
  1692                                                       `new_object` is True. The shape of the interpolated data will be:
  1693                                                       (Naxes_vec, Nspws, Nfeeds or Npols, Nfreqs or freq_array.size if
  1694                                                       freq_array is passed, Npixels/(Naxis1, Naxis2) or az_array.size if
  1695                                                       az/za_arrays are passed)
  1696                                                   interp_basis_vector : array_like of float, optional
  1697                                                       an array of interpolated basis vectors (or self.basis_vector_array
  1698                                                       if az/za_arrays are not passed), shape: (Naxes_vec, Ncomponents_vec,
  1699                                                       Npixels/(Naxis1, Naxis2) or az_array.size if az/za_arrays are passed)
  1700                                                   interp_bandpass : array_like of float, optional
  1701                                                       The interpolated bandpass, only returned if `return_bandpass` is True.
  1702                                                       shape: (Nspws, freq_array.size)
  1703                                           
  1704                                                   """
  1705         1          6.0      6.0      0.0          if self.interpolation_function is None:
  1706                                                       raise ValueError("interpolation_function must be set on object first")
  1707         1          4.0      4.0      0.0          if self.freq_interp_kind is None:
  1708                                                       raise ValueError("freq_interp_kind must be set on object first")
  1709                                           
  1710         1          2.0      2.0      0.0          if new_object:
  1711         1          2.0      2.0      0.0              if not az_za_grid and az_array is not None:
  1712                                                           raise ValueError(
  1713                                                               "A new object can only be returned if "
  1714                                                               "az_za_grid is True or for Healpix pixels or "
  1715                                                               "for frequency only interpolation."
  1716                                                           )
  1717                                           
  1718         1          2.0      2.0      0.0          kind_use = self.freq_interp_kind
  1719         1          2.0      2.0      0.0          if freq_array is not None:
  1720                                                       # get frequency distances
  1721         1         24.0     24.0      0.0              freq_dists = np.abs(self.freq_array - freq_array.reshape(-1, 1))
  1722         1         46.0     46.0      0.0              nearest_dist = np.min(freq_dists, axis=1)
  1723         1         28.0     28.0      0.0              interp_bool = np.any(nearest_dist >= freq_interp_tol)
  1724                                           
  1725                                                       # use the beam at nearest neighbors if not interp_bool
  1726         1          2.0      2.0      0.0              if not interp_bool:
  1727                                                           kind_use = "nearest"
  1728                                           
  1729         1          2.0      2.0      0.0          if az_za_grid:
  1730                                                       az_array_use, za_array_use = np.meshgrid(az_array, za_array)
  1731                                                       az_array_use = az_array_use.flatten()
  1732                                                       za_array_use = za_array_use.flatten()
  1733                                                   else:
  1734         1          7.0      7.0      0.0              az_array_use = copy.copy(az_array)
  1735         1          4.0      4.0      0.0              za_array_use = copy.copy(za_array)
  1736                                           
  1737         1          2.0      2.0      0.0          if healpix_nside is not None or healpix_inds is not None:
  1738                                                       if healpix_nside is None:
  1739                                                           raise ValueError("healpix_nside must be set if healpix_inds is set.")
  1740                                                       if az_array is not None or za_array is not None:
  1741                                                           raise ValueError(
  1742                                                               "healpix_nside and healpix_inds can not be "
  1743                                                               "set if az_array or za_array is set."
  1744                                                           )
  1745                                                       try:
  1746                                                           from astropy_healpix import HEALPix
  1747                                                       except ImportError as e:  # pragma: no cover
  1748                                                           raise ImportError(
  1749                                                               "astropy_healpix is not installed but is "
  1750                                                               "required for healpix functionality. "
  1751                                                               'Install "astropy-healpix" using conda or pip.'
  1752                                                           ) from e
  1753                                           
  1754                                                       hp_obj = HEALPix(nside=healpix_nside)
  1755                                                       if healpix_inds is None:
  1756                                                           healpix_inds = np.arange(hp_obj.npix)
  1757                                           
  1758                                                       hpx_lon, hpx_lat = hp_obj.healpix_to_lonlat(healpix_inds)
  1759                                           
  1760                                                       za_array_use = (Angle(np.pi / 2, units.radian) - hpx_lat).radian
  1761                                                       az_array_use = hpx_lon.radian
  1762                                           
  1763         2          7.0      3.5      0.0          interp_func = self.interpolation_function_dict[self.interpolation_function][
  1764         1          2.0      2.0      0.0              "func"
  1765                                                   ]
  1766                                           
  1767         1          2.0      2.0      0.0          extra_keyword_dict = {}
  1768         1          2.0      2.0      0.0          if interp_func == "_interp_az_za_rect_spline":
  1769         1          2.0      2.0      0.0              extra_keyword_dict["reuse_spline"] = reuse_spline
  1770         1          2.0      2.0      0.0              extra_keyword_dict["spline_opts"] = spline_opts
  1771         1          2.0      2.0      0.0              extra_keyword_dict["check_azza_domain"] = check_azza_domain
  1772                                           
  1773         4    6315662.0 1578915.5     94.5          interp_data, interp_basis_vector, interp_bandpass = getattr(self, interp_func)(
  1774         1          2.0      2.0      0.0              az_array_use,
  1775         1          1.0      1.0      0.0              za_array_use,
  1776         1          2.0      2.0      0.0              freq_array,
  1777         1          1.0      1.0      0.0              freq_interp_kind=kind_use,
  1778         1          1.0      1.0      0.0              polarizations=polarizations,
  1779         1          2.0      2.0      0.0              **extra_keyword_dict,
  1780                                                   )
  1781                                           
  1782                                                   # return just the interpolated arrays
  1783         1          3.0      3.0      0.0          if not new_object:
  1784                                                       if return_bandpass:
  1785                                                           return interp_data, interp_basis_vector, interp_bandpass
  1786                                                       else:
  1787                                                           return interp_data, interp_basis_vector
  1788                                           
  1789                                                   # return a new UVBeam object with interpolated data
  1790                                                   else:
  1791                                                       # make a new object
  1792         1     362624.0 362624.0      5.4              new_uvb = self.copy()
  1793                                           
  1794         1          3.0      3.0      0.0              history_update_string = " Interpolated"
  1795         1          2.0      2.0      0.0              if freq_array is not None:
  1796         1          3.0      3.0      0.0                  history_update_string += " in frequency"
  1797         1          9.0      9.0      0.0                  new_uvb.Nfreqs = freq_array.size
  1798         1         11.0     11.0      0.0                  new_uvb.freq_array = freq_array.reshape(1, -1)
  1799         1          4.0      4.0      0.0                  new_uvb.bandpass_array = interp_bandpass
  1800         1          4.0      4.0      0.0                  new_uvb.freq_interp_kind = kind_use
  1801                                           
  1802         1          2.0      2.0      0.0              if az_array is not None:
  1803                                                           if freq_array is not None:
  1804                                                               history_update_string += " and"
  1805                                                           if new_uvb.pixel_coordinate_system != "az_za":
  1806                                                               input_desc = self.coordinate_system_dict[
  1807                                                                   new_uvb.pixel_coordinate_system
  1808                                                               ]["description"]
  1809                                                               output_desc = self.coordinate_system_dict["az_za"]["description"]
  1810                                                               history_update_string += (
  1811                                                                   " from " + input_desc + " to " + output_desc
  1812                                                               )
  1813                                                               new_uvb.pixel_coordinate_system = "az_za"
  1814                                                               new_uvb.Npixels = None
  1815                                                               new_uvb.pixel_array = None
  1816                                                               new_uvb.nside = None
  1817                                                               new_uvb.ordering = None
  1818                                                           else:
  1819                                                               history_update_string += " to a new azimuth/zenith angle grid"
  1820                                           
  1821                                                           interp_data = interp_data.reshape(
  1822                                                               interp_data.shape[:-1] + (za_array.size, az_array.size)
  1823                                                           )
  1824                                                           if interp_basis_vector is not None:
  1825                                                               interp_basis_vector = interp_basis_vector.reshape(
  1826                                                                   interp_basis_vector.shape[:-1] + (za_array.size, az_array.size)
  1827                                                               )
  1828                                           
  1829                                                           new_uvb.axis1_array = az_array
  1830                                                           new_uvb.axis2_array = za_array
  1831                                                           new_uvb.Naxes1 = new_uvb.axis1_array.size
  1832                                                           new_uvb.Naxes2 = new_uvb.axis2_array.size
  1833                                           
  1834         1          1.0      1.0      0.0              elif healpix_nside is not None:
  1835                                                           if freq_array is not None:
  1836                                                               history_update_string += " and"
  1837                                                           if new_uvb.pixel_coordinate_system != "healpix":
  1838                                                               input_desc = self.coordinate_system_dict[
  1839                                                                   new_uvb.pixel_coordinate_system
  1840                                                               ]["description"]
  1841                                                               output_desc = self.coordinate_system_dict["healpix"]["description"]
  1842                                                               history_update_string += (
  1843                                                                   " from " + input_desc + " to " + output_desc
  1844                                                               )
  1845                                                               new_uvb.pixel_coordinate_system = "healpix"
  1846                                                               new_uvb.Naxes1 = None
  1847                                                               new_uvb.axis1_array = None
  1848                                                               new_uvb.Naxes2 = None
  1849                                                               new_uvb.axis2_array = None
  1850                                                           else:
  1851                                                               history_update_string += " to a new healpix grid"
  1852                                           
  1853                                                           new_uvb.pixel_array = healpix_inds
  1854                                                           new_uvb.Npixels = new_uvb.pixel_array.size
  1855                                                           new_uvb.nside = healpix_nside
  1856                                                           new_uvb.ordering = "ring"
  1857                                           
  1858         2          3.0      1.5      0.0              history_update_string += (
  1859         2          3.0      1.5      0.0                  " using pyuvdata with interpolation_function = "
  1860         1          3.0      3.0      0.0                  + new_uvb.interpolation_function
  1861                                                       )
  1862         1          2.0      2.0      0.0              if freq_array is not None:
  1863         2          4.0      2.0      0.0                  history_update_string += (
  1864         1          3.0      3.0      0.0                      " and freq_interp_kind = " + new_uvb.freq_interp_kind
  1865                                                           )
  1866         1          2.0      2.0      0.0              history_update_string += "."
  1867         1          4.0      4.0      0.0              new_uvb.history = new_uvb.history + history_update_string
  1868         1       2334.0   2334.0      0.0              new_uvb.data_array = interp_data
  1869         1          4.0      4.0      0.0              if new_uvb.basis_vector_array is not None:
  1870         1          5.0      5.0      0.0                  new_uvb.basis_vector_array = interp_basis_vector
  1871                                           
  1872         1          3.0      3.0      0.0              if hasattr(new_uvb, "saved_interp_functions"):
  1873                                                           delattr(new_uvb, "saved_interp_functions")
  1874                                           
  1875         1         26.0     26.0      0.0              new_uvb._set_cs_params()
  1876         1          1.0      1.0      0.0              if run_check:
  1877                                                           new_uvb.check(
  1878                                                               check_extra=check_extra,
  1879                                                               run_check_acceptability=run_check_acceptability,
  1880                                                           )
  1881         1          2.0      2.0      0.0              return new_uvb

Total time: 6.68161 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/vis_cpu/cpu.py
Function: _wrangle_beams at line 26

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    26                                           def _wrangle_beams(
    27                                               beam_idx: np.ndarray,
    28                                               beam_list: list[UVBeam],
    29                                               polarized: bool,
    30                                               nant: int,
    31                                               freq: float,
    32                                           ) -> tuple[list[UVBeam], int, np.ndarray]:
    33                                               """Perform all the operations and checks on the input beams.
    34                                           
    35                                               Checks that the beam indices match the number of antennas, pre-interpolates to the
    36                                               given frequency, and checks that the beam type is appropriate for the given
    37                                               polarization
    38                                           
    39                                               Parameters
    40                                               ----------
    41                                               beam_idx
    42                                                   Index of the beam to use for each antenna.
    43                                               beam_list
    44                                                   List of unique beams.
    45                                               polarized
    46                                                   Whether to use beam polarization
    47                                               nant
    48                                                   Number of antennas
    49                                               freq
    50                                                   Frequency to interpolate beam to.
    51                                               """
    52                                               # Get the number of unique beams
    53         1          2.0      2.0      0.0      nbeam = len(beam_list)
    54                                           
    55                                               # Check the beam indices
    56         1          1.0      1.0      0.0      if beam_idx is None:
    57                                                   if nbeam == 1:
    58                                                       beam_idx = np.zeros(nant, dtype=int)
    59                                                   elif nbeam == nant:
    60                                                       beam_idx = np.arange(nant, dtype=int)
    61                                                   else:
    62                                                       raise ValueError(
    63                                                           "If number of beams provided is not 1 or nant, beam_idx must be provided."
    64                                                       )
    65                                               else:
    66         1          2.0      2.0      0.0          assert beam_idx.shape == (nant,), "beam_idx must be length nant"
    67         2        529.0    264.5      0.0          assert all(
    68         1          1.0      1.0      0.0              0 <= i < nbeam for i in beam_idx
    69                                                   ), "beam_idx contains indices greater than the number of beams"
    70                                           
    71                                               # make sure we interpolate to the right frequency first.
    72         2    6681068.0 3340534.0    100.0      beam_list = [
    73                                                   bm.interp(freq_array=np.array([freq]), new_object=True, run_check=False)
    74                                                   if isinstance(bm, UVBeam)
    75                                                   else bm
    76         1          1.0      1.0      0.0          for bm in beam_list
    77                                               ]
    78                                           
    79         1          7.0      7.0      0.0      if polarized and any(b.beam_type != "efield" for b in beam_list):
    80                                                   raise ValueError("beam type must be efield if using polarized=True")
    81         1          2.0      2.0      0.0      elif not polarized and any(
    82                                                   (
    83                                                       b.beam_type != "power"
    84                                                       or getattr(b, "Npols", 1) > 1
    85                                                       or b.polarization_array[0] not in [-5, -6]
    86                                                   )
    87                                                   for b in beam_list
    88                                               ):
    89                                                   raise ValueError(
    90                                                       "beam type must be power and have only one pol (either xx or yy) if polarized=False"
    91                                                   )
    92                                           
    93         1          1.0      1.0      0.0      return beam_list, nbeam, beam_idx

Total time: 0 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/vis_cpu/cpu.py
Function: _evaluate_beam_cpu at line 96

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    96                                           def _evaluate_beam_cpu(
    97                                               A_s: np.ndarray,
    98                                               beam_list: list[UVBeam],
    99                                               tx: np.ndarray,
   100                                               ty: np.ndarray,
   101                                               polarized: bool,
   102                                               freq: float,
   103                                               check: bool = False,
   104                                               spline_opts: dict | None = None,
   105                                           ):
   106                                               """Evaluate the beam on the CPU.
   107                                           
   108                                               This function will either interpolate the beam to the given coordinates tx, ty,
   109                                               or evaluate the beam there if it is an analytic beam.
   110                                           
   111                                               Parameters
   112                                               ----------
   113                                               A_s
   114                                                   Array of shape (nax, nfeed, nbeam, nsrcs_up) that will be filled with beam
   115                                                   values.
   116                                               beam_list
   117                                                   List of unique beams.
   118                                               tx, ty
   119                                                   Coordinates to evaluate the beam at, in sin-projection.
   120                                               polarized
   121                                                   Whether to use beam polarization.
   122                                               freq
   123                                                   Frequency to interpolate beam to.
   124                                               spline_opts
   125                                                   Extra options to pass to the RectBivariateSpline class when interpolating.
   126                                               """
   127                                               # Primary beam pattern using direct interpolation of UVBeam object
   128                                               az, za = conversions.enu_to_az_za(enu_e=tx, enu_n=ty, orientation="uvbeam")
   129                                               for i, bm in enumerate(beam_list):
   130                                                   kw = (
   131                                                       {
   132                                                           "reuse_spline": True,
   133                                                           "check_azza_domain": False,
   134                                                           "spline_opts": spline_opts,
   135                                                       }
   136                                                       if isinstance(bm, UVBeam)
   137                                                       else {}
   138                                                   )
   139                                           
   140                                                   interp_beam = bm.interp(
   141                                                       az_array=az,
   142                                                       za_array=za,
   143                                                       freq_array=np.atleast_1d(freq),
   144                                                       **kw,
   145                                                   )[0]
   146                                           
   147                                                   if polarized:
   148                                                       interp_beam = interp_beam[:, 0, :, 0, :]
   149                                                   else:
   150                                                       # Here we have already asserted that the beam is a power beam and
   151                                                       # has only one polarization, so we just evaluate that one.
   152                                                       interp_beam = np.sqrt(interp_beam[0, 0, 0, 0, :])
   153                                           
   154                                                   A_s[:, :, i] = interp_beam
   155                                           
   156                                                   # Check for invalid beam values
   157                                                   if check:
   158                                                       sm = np.sum(A_s)
   159                                                       if np.isinf(sm) or np.isnan(sm):
   160                                                           raise ValueError("Beam interpolation resulted in an invalid value")
   161                                           
   162                                               return A_s

Total time: 10.8358 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/vis_cpu/gpu.py
Function: vis_gpu at line 87

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    87                                           @profile
    88                                           def vis_gpu(
    89                                               *,
    90                                               antpos: np.ndarray,
    91                                               freq: float,
    92                                               eq2tops: np.ndarray,
    93                                               crd_eq: np.ndarray,
    94                                               I_sky: np.ndarray,
    95                                               beam_list: Sequence[UVBeam | Callable] | None,
    96                                               polarized: bool = False,
    97                                               beam_idx: np.ndarray | None = None,
    98                                               nthreads: int = 1024,
    99                                               max_memory: int = 2**29,
   100                                               min_chunks: int = 1,
   101                                               precision: int = 1,
   102                                               beam_spline_opts: dict | None = None,
   103                                           ) -> np.ndarray:
   104                                               """GPU implementation of the visibility simulator."""
   105         1          6.0      6.0      0.0      if not HAVE_CUDA:
   106                                                   raise ImportError("You need to install the [gpu] extra to use this function!")
   107                                           
   108         2         17.0      8.5      0.0      nax, nfeed, nant, ntimes = _validate_inputs(
   109         1          4.0      4.0      0.0          precision, polarized, antpos, eq2tops, crd_eq, I_sky
   110                                               )
   111                                           
   112         1          4.0      4.0      0.0      if beam_spline_opts:
   113                                                   warnings.warn(
   114                                                       "You have passed beam_spline_opts, but these are not used in GPU."
   115                                                   )
   116                                           
   117         1          4.0      4.0      0.0      nsrc = len(I_sky)
   118                                           
   119         1          4.0      4.0      0.0      if precision == 1:
   120                                                   real_dtype, complex_dtype = np.float32, np.complex64
   121                                                   cublas_real_mm = cublasSgemm
   122                                                   cublas_complex_mm = cublasCgemm
   123                                               else:
   124         1          5.0      5.0      0.0          real_dtype, complex_dtype = np.float64, np.complex128
   125         1          4.0      4.0      0.0          cublas_real_mm = cublasDgemm
   126         1          4.0      4.0      0.0          cublas_complex_mm = cublasZgemm
   127                                           
   128         1          4.0      4.0      0.0      DTYPE, CDTYPE = TYPE_MAP[real_dtype], TYPE_MAP[complex_dtype]
   129                                           
   130                                               # apply scalars so 1j*tau*freq is the correct exponent
   131         1          5.0      5.0      0.0      ang_freq = 2 * freq * np.pi
   132                                           
   133                                               # ensure data types
   134         1          9.0      9.0      0.0      antpos = antpos.astype(real_dtype)
   135         1          5.0      5.0      0.0      eq2tops = eq2tops.astype(real_dtype)
   136         1        742.0    742.0      0.0      crd_eq = crd_eq.astype(real_dtype)
   137         1        880.0    880.0      0.0      Isqrt = np.sqrt(0.5 * I_sky).astype(real_dtype)
   138                                           
   139         2         10.0      5.0      0.0      chunk = max(
   140         1          6.0      6.0      0.0          min(nsrc, min_chunks),
   141         1         24.0     24.0      0.0          2 ** int(np.ceil(np.log2(float(nant * nsrc) / max_memory / 2))),
   142                                               )
   143         1          4.0      4.0      0.0      npixc = nsrc // chunk
   144                                           
   145         2    6681670.0 3340835.0     61.7      beam_list, nbeam, beam_idx = _wrangle_beams(
   146         1          4.0      4.0      0.0          beam_idx=beam_idx,
   147         1          3.0      3.0      0.0          beam_list=beam_list,
   148         1          4.0      4.0      0.0          polarized=polarized,
   149         1          4.0      4.0      0.0          nant=nant,
   150         1          3.0      3.0      0.0          freq=freq,
   151                                               )
   152                                           
   153                                               # Ways to block up threads for sending to GPU calculations. "Meas" is for the
   154                                               # measurement equation function, and "prod" is for the inner-product calculation.
   155         1          3.0      3.0      0.0      meas_block = (
   156         1          8.0      8.0      0.0          max(1, nthreads // (nant * nax * nfeed)),
   157         1          5.0      5.0      0.0          min(nthreads, nant * nax),
   158         1          4.0      4.0      0.0          min(nthreads, nfeed),
   159                                               )
   160                                           
   161         2         51.0     25.5      0.0      logger.info(
   162         1         97.0     97.0      0.0          f"Using {np.prod(meas_block)} threads in total for measurement equation."
   163                                               )
   164         1          8.0      8.0      0.0      logger.info(f"Using a shared-memory buffer of size {5*meas_block[0]}.")
   165                                           
   166         1          5.0      5.0      0.0      use_uvbeam = isinstance(beam_list[0], UVBeam)
   167         1          7.0      7.0      0.0      if use_uvbeam and not all(isinstance(b, UVBeam) for b in beam_list):
   168                                                   raise ValueError(
   169                                                       "vis_gpu only support beam_lists with either all UVBeam or all AnalyticBeam objects."
   170                                                   )
   171                                           
   172         1          5.0      5.0      0.0      cuda_params = {
   173         1          4.0      4.0      0.0          "NANT": nant,
   174         1          4.0      4.0      0.0          "NAX": nax,
   175         1          4.0      4.0      0.0          "NFEED": nfeed,
   176         1          4.0      4.0      0.0          "NBEAM": nbeam,
   177         1          3.0      3.0      0.0          "BLOCK_PX": meas_block[0],
   178         1          4.0      4.0      0.0          "DTYPE": DTYPE,
   179         1          4.0      4.0      0.0          "CDTYPE": CDTYPE,
   180         1          4.0      4.0      0.0          "f": "f" if precision == 1 else "",
   181                                               }
   182                                           
   183         1          3.0      3.0      0.0      if use_uvbeam:
   184                                                   # We need to make sure that each beam "raw" data is on the same grid.
   185                                                   # There is no advantage to using any other resolution but the native raw
   186                                                   # resolution, which is what is returned by default. This may not be the case
   187                                                   # if we were to use higher-order splines in the initial interpolation from
   188                                                   # UVBeam. Eg. if "cubic" interpolation was shown to be better than linear,
   189                                                   # we might want to do cubic interpolation with pyuvbeam onto a much higher-res
   190                                                   # grid, then use linear interpolation on the GPU with that high-res grid.
   191                                                   # We can explore this later...
   192         1       2132.0   2132.0      0.0          d0, daz, dza = uvbeam_to_azza_grid(beam_list[0])
   193         1          7.0      7.0      0.0          naz = 2 * np.pi / daz + 1
   194         1        103.0    103.0      0.0          assert np.isclose(int(naz), naz)
   195                                           
   196         1          5.0      5.0      0.0          raw_beam_data = [d0]
   197         1          4.0      4.0      0.0          if len(beam_list) > 1:
   198                                                       raw_beam_data.extend(
   199                                                           uvbeam_to_azza_grid(b, naz=int(naz), dza=dza)[0] for b in beam_list[1:]
   200                                                       )
   201                                               else:
   202                                                   daz, dza = None, None
   203                                           
   204                                               # Setup the GPU code and arrays
   205         1        243.0    243.0      0.0      meas_eq_code = MeasEqTemplate.render(**cuda_params)
   206                                           
   207         1          4.0      4.0      0.0      if use_uvbeam:
   208         2        234.0    117.0      0.0          beam_interp_code = BeamInterpTemplate.render(
   209         3         13.0      4.3      0.0              **{
   210         1          4.0      4.0      0.0                  **cuda_params,
   211         1          4.0      4.0      0.0                  **{
   212         1          3.0      3.0      0.0                      "NBEAM": nbeam,
   213         1          4.0      4.0      0.0                      "BEAM_N_AZ": raw_beam_data[0].shape[-1],
   214         1          4.0      4.0      0.0                      "BEAM_N_ZA": raw_beam_data[0].shape[-2],
   215         1          4.0      4.0      0.0                      "DAZ": daz,
   216         1          4.0      4.0      0.0                      "DZA": dza,
   217                                                           },
   218                                                       }
   219                                                   )
   220         1    1433230.0 1433230.0     13.2          beam_interp_module = compiler.SourceModule(beam_interp_code)
   221         1         38.0     38.0      0.0          beam_interp = beam_interp_module.get_function("InterpolateBeamAltAz")
   222                                               else:
   223                                                   beam_interp = None
   224                                           
   225         1     623763.0 623763.0      5.8      meas_eq_module = compiler.SourceModule(meas_eq_code)
   226         1         16.0     16.0      0.0      meas_eq = meas_eq_module.get_function("MeasEq")
   227                                               # vis_inner_product = meas_eq_module.get_function("VisInnerProduct")
   228                                           
   229         2         18.0      9.0      0.0      logger.info(
   230         5         22.0      4.4      0.0          f"""
   231                                                   Measurement Equation Kernel Properties:
   232         1       2309.0   2309.0      0.0              SHARED: {meas_eq.shared_size_bytes}
   233         1         13.0     13.0      0.0              LOCAL: {meas_eq.local_size_bytes}
   234         1          8.0      8.0      0.0              REGISTERS: {meas_eq.num_regs}
   235         1          8.0      8.0      0.0              MAX_THREADS_PER_BLOCK: {meas_eq.max_threads_per_block}
   236                                                   """
   237                                               )
   238                                           
   239                                               # bm_texref = gpu_module.get_texref("bm_tex")
   240         1        607.0    607.0      0.0      h = cublasCreate()  # handle for managing cublas
   241                                           
   242                                               # define GPU buffers and transfer initial values
   243                                               # never changes, transpose happens in copy so cuda bm_tex is (BEAM_PX,BEAM_PX,NANT)
   244                                               # bm_texref.set_array(numpy3d_to_array(beams))
   245         1        535.0    535.0      0.0      antpos_gpu = gpuarray.to_gpu(antpos)  # never changes, set to -2*pi*antpos/c
   246         1        457.0    457.0      0.0      beam_idx = gpuarray.to_gpu(beam_idx.astype(np.uint))
   247         1         82.0     82.0      0.0      Isqrt_gpu = gpuarray.empty(shape=(npixc,), dtype=real_dtype)
   248                                           
   249                                               # Send the regular-grid beam data to the GPU. This has dimensions (Nbeam, Nax, Nfeed, Nza, Nza)
   250                                               # Note that Nbeam is not in general equal to Nant (we can have multiple antennas with
   251                                               # the same beam).
   252         1          5.0      5.0      0.0      if use_uvbeam:
   253         2        962.0    481.0      0.0          beam_data_gpu = gpuarray.to_gpu(
   254         1       1964.0   1964.0      0.0              np.array(raw_beam_data, dtype=complex_dtype if polarized else real_dtype),
   255                                                   )
   256                                               else:
   257                                                   beam_data_gpu = None
   258                                           
   259                                               # will be set on GPU by bm_interp
   260         1        250.0    250.0      0.0      crd_eq_gpu = gpuarray.empty(shape=(3, npixc), dtype=real_dtype)
   261                                               # sent from CPU each time
   262         1         79.0     79.0      0.0      eq2top_gpu = gpuarray.empty(shape=(3, 3), dtype=real_dtype)
   263                                               # will be set on GPU
   264         1        185.0    185.0      0.0      crdtop_gpu = gpuarray.empty(shape=(3, npixc), dtype=real_dtype)
   265                                               # will be set on GPU
   266         2        193.0     96.5      0.0      vis_gpus = [
   267                                                   gpuarray.empty(shape=(nfeed * nant, nfeed * nant), dtype=complex_dtype)
   268         1          5.0      5.0      0.0          for _ in range(chunk)
   269                                               ]
   270                                           
   271                                               # output CPU buffers for downloading answers
   272         2         21.0     10.5      0.0      vis_cpus = [
   273                                                   np.empty(shape=(nfeed * nant, nfeed * nant), dtype=complex_dtype)
   274         1          5.0      5.0      0.0          for _ in range(chunk)
   275                                               ]
   276         1         76.0     76.0      0.0      streams = [driver.Stream() for _ in range(chunk)]
   277         1          5.0      5.0      0.0      event_order = [
   278                                                   "start",
   279                                                   "upload",
   280                                                   "eq2top",
   281                                                   "tau",
   282                                                   "meas_eq",
   283                                                   "vis",
   284                                                   "end",
   285                                               ]
   286                                           
   287         1          4.0      4.0      0.0      if use_uvbeam:
   288         1          7.0      7.0      0.0          event_order.insert(4, "interpolation")
   289                                           
   290         1          9.0      9.0      0.0      vis = np.empty((ntimes, nfeed * nant, nfeed * nant), dtype=complex_dtype)
   291                                           
   292         1          8.0      8.0      0.0      logger.info("Running With %s chunks: ", chunk)
   293                                           
   294         4         19.0      4.8      0.0      for t in range(ntimes):
   295         3        306.0    102.0      0.0          eq2top_gpu.set(eq2tops[t])  # defines sky orientation for this time step
   296         3        173.0     57.7      0.0          events = [{e: driver.Event() for e in event_order} for _ in range(chunk)]
   297                                           
   298        12         51.0      4.2      0.0          for c in range(chunk + 2):
   299         9         37.0      4.1      0.0              cc = c - 1
   300         9         34.0      3.8      0.0              ccc = c - 2
   301         9         40.0      4.4      0.0              if 0 <= ccc < chunk:
   302         3         12.0      4.0      0.0                  stream = streams[ccc]
   303         3      95474.0  31824.7      0.9                  vis_gpus[ccc].get(ary=vis_cpus[ccc], stream=stream)
   304         3         36.0     12.0      0.0                  events[ccc]["end"].record(stream)
   305         9         38.0      4.2      0.0              if 0 <= cc < chunk:
   306         3         13.0      4.3      0.0                  stream = streams[cc]
   307         3         63.0     21.0      0.0                  cublasSetStream(h, stream.handle)
   308                                           
   309                                                           # cublas arrays are in Fortran order, so P=M*N is actually
   310                                                           # peformed as P.T = N.T * M.T
   311         6        256.0     42.7      0.0                  cublas_real_mm(  # compute crdtop = dot(eq2top,crd_eq)
   312         3         11.0      3.7      0.0                      h,
   313         3         12.0      4.0      0.0                      "n",
   314         3         11.0      3.7      0.0                      "n",
   315         3         12.0      4.0      0.0                      npixc,
   316         3         11.0      3.7      0.0                      3,
   317         3         11.0      3.7      0.0                      3,
   318         3         11.0      3.7      0.0                      1.0,
   319         3         12.0      4.0      0.0                      crd_eq_gpu.gpudata,
   320         3         11.0      3.7      0.0                      npixc,
   321         3         11.0      3.7      0.0                      eq2top_gpu.gpudata,
   322         3         10.0      3.3      0.0                      3,
   323         3         10.0      3.3      0.0                      0.0,
   324         3         11.0      3.7      0.0                      crdtop_gpu.gpudata,
   325         3         10.0      3.3      0.0                      npixc,
   326                                                           )
   327         3         29.0      9.7      0.0                  events[cc]["eq2top"].record(stream)
   328                                           
   329         3       4359.0   1453.0      0.0                  tx, ty, tz = crdtop_gpu.get_async(stream=stream)
   330         3        758.0    252.7      0.0                  above_horizon = tz > 0
   331         3       4412.0   1470.7      0.0                  tx = tx[above_horizon]
   332         3       4826.0   1608.7      0.0                  ty = ty[above_horizon]
   333         3         15.0      5.0      0.0                  nsrcs_up = len(tx)
   334         6       3004.0    500.7      0.0                  crdtop_lim_gpu = gpuarray.to_gpu_async(
   335         3      18801.0   6267.0      0.2                      crdtop_gpu.get_async(stream=stream)[:, above_horizon].copy(),
   336         3         14.0      4.7      0.0                      stream=stream,
   337                                                           )
   338                                           
   339         3         16.0      5.3      0.0                  if nsrcs_up < 1:
   340                                                               continue
   341                                           
   342         3       1475.0    491.7      0.0                  tau_gpu = gpuarray.empty(shape=(nant, nsrcs_up), dtype=real_dtype)
   343                                           
   344         6        256.0     42.7      0.0                  cublas_real_mm(  # compute tau = dot(antpos,crdtop) / speed_of_light
   345         3         12.0      4.0      0.0                      h,
   346         3         11.0      3.7      0.0                      "n",
   347         3         12.0      4.0      0.0                      "n",
   348         3         12.0      4.0      0.0                      nsrcs_up,
   349         3         12.0      4.0      0.0                      nant,
   350         3         11.0      3.7      0.0                      3,
   351         3         12.0      4.0      0.0                      ONE_OVER_C,
   352         3         11.0      3.7      0.0                      crdtop_lim_gpu.gpudata,
   353         3         11.0      3.7      0.0                      nsrcs_up,
   354         3         12.0      4.0      0.0                      antpos_gpu.gpudata,
   355         3         11.0      3.7      0.0                      3,
   356         3         10.0      3.3      0.0                      0.0,
   357         3         11.0      3.7      0.0                      tau_gpu.gpudata,
   358         3         11.0      3.7      0.0                      nsrcs_up,
   359                                                           )
   360         3         32.0     10.7      0.0                  events[cc]["tau"].record(stream)
   361                                           
   362                                                           # Need to do this in polar coordinates, NOT (l,m), at least for
   363                                                           # polarized beams. This is because at zenith, the Efield components are
   364                                                           # discontinuous (in power they are continuous). When interpolating the
   365                                                           # E-field components, you need to treat the zenith point differently
   366                                                           # depending on which "side" of zenith you're on. This is doable in polar
   367                                                           # coordinates, but not in Cartesian coordinates.
   368         6    1918924.0 319820.7     17.7                  A_gpu = do_beam_interpolation(
   369         3         12.0      4.0      0.0                      freq,
   370         3         11.0      3.7      0.0                      beam_list,
   371         3         11.0      3.7      0.0                      polarized,
   372         3         11.0      3.7      0.0                      nthreads,
   373         3         11.0      3.7      0.0                      nax,
   374         3         12.0      4.0      0.0                      nfeed,
   375         3         12.0      4.0      0.0                      complex_dtype,
   376         3         11.0      3.7      0.0                      nbeam,
   377         3         10.0      3.3      0.0                      use_uvbeam,
   378         3          9.0      3.0      0.0                      daz,
   379         3         10.0      3.3      0.0                      dza,
   380         3         10.0      3.3      0.0                      beam_interp,
   381         3         12.0      4.0      0.0                      beam_data_gpu,
   382         3         12.0      4.0      0.0                      events,
   383         3         12.0      4.0      0.0                      cc,
   384         3         11.0      3.7      0.0                      stream,
   385         3         11.0      3.7      0.0                      tx,
   386         3         10.0      3.3      0.0                      ty,
   387         3         10.0      3.3      0.0                      nsrcs_up,
   388                                                           )
   389                                           
   390         6       5423.0    903.8      0.1                  v_gpu = gpuarray.empty(
   391         3         15.0      5.0      0.0                      shape=(nfeed * nant, nax * nsrcs_up), dtype=complex_dtype
   392                                                           )
   393         6       7877.0   1312.8      0.1                  Isqrt_lim_gpu = gpuarray.to_gpu_async(
   394         3       6240.0   2080.0      0.1                      Isqrt_gpu.get()[above_horizon].copy(), stream=stream
   395                                                           )
   396                                           
   397                                                           # blocks of threads are mapped to (pixels,ants,freqs)
   398                                           
   399         3         12.0      4.0      0.0                  grid = (
   400         3         61.0     20.3      0.0                      int(np.ceil(nsrcs_up / float(meas_block[0]))),
   401         3         20.0      6.7      0.0                      int(np.ceil(nax * nant / float(meas_block[1]))),
   402         3         16.0      5.3      0.0                      int(np.ceil(nfeed / float(meas_block[2]))),
   403                                                           )
   404                                           
   405         3         49.0     16.3      0.0                  logger.info(f"Measurement Eq. Grid Size: {grid}")
   406                                           
   407         3         31.0     10.3      0.0                  _logdebug(A_gpu, "Beam")
   408                                           
   409                                                           # compute v = A * sqrtI * exp(1j*tau*freq)
   410         6        373.0     62.2      0.0                  meas_eq(
   411         3         11.0      3.7      0.0                      A_gpu,
   412         3         11.0      3.7      0.0                      Isqrt_lim_gpu,
   413         3         11.0      3.7      0.0                      tau_gpu,
   414         3         11.0      3.7      0.0                      ang_freq,
   415         3         23.0      7.7      0.0                      np.uint(nsrcs_up),
   416         3         11.0      3.7      0.0                      beam_idx,
   417         3         11.0      3.7      0.0                      v_gpu,
   418         3         12.0      4.0      0.0                      grid=grid,
   419         3         11.0      3.7      0.0                      block=meas_block,
   420         3         12.0      4.0      0.0                      stream=stream,
   421                                                           )
   422         3         30.0     10.0      0.0                  events[cc]["meas_eq"].record(stream)
   423                                           
   424         3         25.0      8.3      0.0                  _logdebug(v_gpu, "vant")
   425                                           
   426                                                           # compute vis = dot(v, v.T)
   427                                                           # We want to take an outer product over feeds/antennas, contract over
   428                                                           # E-field components, and integrate over the sky.
   429                                                           # Remember cublas is in fortran order...
   430                                                           # v_gpu is (nfeed * nant, nax * nsrcs_up)
   431         6       2664.0    444.0      0.0                  cublas_complex_mm(
   432         3         12.0      4.0      0.0                      h,
   433         3         12.0      4.0      0.0                      "c",  # conjugate transpose for first (remember fortran order)
   434         3         11.0      3.7      0.0                      "n",  # no transpose for second.
   435         3         12.0      4.0      0.0                      nfeed * nant,
   436         3         12.0      4.0      0.0                      nfeed * nant,
   437         3         12.0      4.0      0.0                      nax * nsrcs_up,
   438         3         11.0      3.7      0.0                      1.0,
   439         3         12.0      4.0      0.0                      v_gpu.gpudata,
   440         3         11.0      3.7      0.0                      nax * nsrcs_up,
   441         3         11.0      3.7      0.0                      v_gpu.gpudata,
   442         3         11.0      3.7      0.0                      nax * nsrcs_up,
   443         3         12.0      4.0      0.0                      0.0,
   444         3         12.0      4.0      0.0                      vis_gpus[cc].gpudata,
   445         3         12.0      4.0      0.0                      nfeed * nant,
   446                                                           )
   447                                           
   448         3         26.0      8.7      0.0                  _logdebug(vis_gpus[cc], "Vis")
   449                                           
   450         3         27.0      9.0      0.0                  events[cc]["vis"].record(stream)
   451                                           
   452         9         41.0      4.6      0.0              if c < chunk:
   453                                                           # This is the first thing that happens in the loop over chunks.
   454                                           
   455         3         12.0      4.0      0.0                  stream = streams[c]
   456         3         54.0     18.0      0.0                  events[c]["start"].record(stream)
   457         6       3488.0    581.3      0.0                  crd_eq_gpu.set_async(
   458         3         20.0      6.7      0.0                      crd_eq[:, c * npixc : (c + 1) * npixc], stream=stream
   459                                                           )
   460         3       1390.0    463.3      0.0                  Isqrt_gpu.set_async(Isqrt[c * npixc : (c + 1) * npixc], stream=stream)
   461         3         34.0     11.3      0.0                  events[c]["upload"].record(stream)
   462                                           
   463         3         26.0      8.7      0.0          events[chunk - 1]["end"].synchronize()
   464         3        852.0    284.0      0.0          vis[t] = sum(vis_cpus)
   465                                           
   466                                               # teardown GPU configuration
   467         1        898.0    898.0      0.0      cublasDestroy(h)
   468         1        506.0    506.0      0.0      vis = vis.conj().reshape((ntimes, nfeed, nant, nfeed, nant))
   469         1          7.0      7.0      0.0      return vis.transpose((0, 1, 3, 2, 4)) if polarized else vis[:, 0, :, 0, :]

