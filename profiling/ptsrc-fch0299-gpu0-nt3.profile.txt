Timer unit: 1e-06 s

Total time: 23.6516 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/hera_sim/visibilities/vis_cpu.py
Function: simulate at line 291

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   291                                               def simulate(self, data_model):
   292                                                   """
   293                                                   Calls :func:vis_cpu to perform the visibility calculation.
   294                                           
   295                                                   Returns
   296                                                   -------
   297                                                   array_like of self._complex_dtype
   298                                                       Visibilities. Shape=self.uvdata.data_array.shape.
   299                                                   """
   300         1         13.0     13.0      0.0          polarized = self._check_if_polarized(data_model)
   301         1        126.0    126.0      0.0          feed = self.get_feed(data_model.uvdata)
   302                                           
   303                                                   # Setup MPI info if enabled
   304         1          1.0      1.0      0.0          if self.mpi_comm is not None:
   305                                                       myid = self.mpi_comm.Get_rank()
   306                                                       nproc = self.mpi_comm.Get_size()
   307                                           
   308         1          1.0      1.0      0.0          if self.correct_source_positions:
   309                                                       # TODO: check if this is the right time to be using...
   310         2     133704.0  66852.0      0.6              ra, dec = self.correct_point_source_pos(
   311         1        241.0    241.0      0.0                  data_model, obstime=Time(data_model.uvdata.time_array[0], format="jd")
   312                                                       )
   313                                                   else:
   314                                                       ra, dec = data_model.sky_model.ra, data_model.sky_model.dec
   315                                           
   316         1       2222.0   2222.0      0.0          crd_eq = convs.point_source_crd_eq(ra, dec)
   317                                           
   318                                                   # Convert equatorial to topocentric coords
   319         1        160.0    160.0      0.0          eq2tops = self.get_eq2tops(data_model.uvdata, data_model.lsts)
   320                                           
   321                                                   # The following are antenna positions in the order that they are
   322                                                   # in the uvdata.data_array
   323         1       1419.0   1419.0      0.0          active_antpos, ant_list = data_model.uvdata.get_ENU_antpos(pick_data_ants=True)
   324                                           
   325                                                   # Get pixelized beams if required
   326                                           
   327         2         24.0     12.0      0.0          beam_list = [
   328                                                       convs.prepare_beam(
   329                                                           beam,
   330                                                           polarized=polarized,
   331                                                           use_feed=feed,
   332                                                       )
   333         1          2.0      2.0      0.0              for beam in data_model.beams
   334                                                   ]
   335         2          9.0      4.5      0.0          beam_ids = np.array(
   336         2        461.0    230.5      0.0              [
   337                                                           data_model.beam_ids[nm]
   338         2          3.0      1.5      0.0                  for i, nm in zip(
   339         1          4.0      4.0      0.0                      data_model.uvdata.antenna_numbers, data_model.uvdata.antenna_names
   340                                                           )
   341                                                           if i in ant_list
   342                                                       ]
   343                                                   )
   344                                           
   345                                                   # Get all the polarizations required to be simulated.
   346         2        346.0    173.0      0.0          req_pols = self._get_req_pols(
   347         1          4.0      4.0      0.0              data_model.uvdata, data_model.beams[0], polarized=polarized
   348                                                   )
   349                                           
   350                                                   # Empty visibility array
   351         1        233.0    233.0      0.0          visfull = np.zeros_like(data_model.uvdata.data_array, dtype=self._complex_dtype)
   352                                           
   353         2          8.0      4.0      0.0          for i, freq in enumerate(data_model.freqs):
   354                                                       # Divide tasks between MPI workers if needed
   355         1          1.0      1.0      0.0              if self.mpi_comm is not None and i % nproc != myid:
   356                                                           continue
   357                                           
   358                                                       # Call vis_cpu function to simulate visibilities
   359         2   22026258.0 11013129.0     93.1              vis = self._vis_cpu(
   360         1          1.0      1.0      0.0                  antpos=active_antpos,
   361         1          1.0      1.0      0.0                  freq=freq,
   362         1          1.0      1.0      0.0                  eq2tops=eq2tops,
   363         1         17.0     17.0      0.0                  crd_eq=crd_eq,
   364         1        335.0    335.0      0.0                  I_sky=data_model.sky_model.stokes[0, i].to("Jy").value,
   365         1          2.0      2.0      0.0                  beam_list=beam_list,
   366         1          1.0      1.0      0.0                  beam_idx=beam_ids,
   367         1          2.0      2.0      0.0                  precision=self._precision,
   368         1          2.0      2.0      0.0                  polarized=polarized,
   369                                                       )
   370                                           
   371         2    1485939.0 742969.5      6.3              self._reorder_vis(
   372         1         14.0     14.0      0.0                  req_pols, data_model.uvdata, visfull[:, 0, i], vis, ant_list, polarized
   373                                                       )
   374                                           
   375                                                   # Reduce visfull array if in MPI mode
   376         1          2.0      2.0      0.0          if self.mpi_comm is not None:
   377                                                       visfull = self._reduce_mpi(visfull, myid)
   378                                           
   379         1          1.0      1.0      0.0          return visfull

Total time: 11.8874 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/pyuvdata/uvbeam/uvbeam.py
Function: interp at line 1611

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
  1611                                               def interp(
  1612                                                   self,
  1613                                                   az_array=None,
  1614                                                   za_array=None,
  1615                                                   az_za_grid=False,
  1616                                                   healpix_nside=None,
  1617                                                   healpix_inds=None,
  1618                                                   freq_array=None,
  1619                                                   freq_interp_tol=1.0,
  1620                                                   polarizations=None,
  1621                                                   return_bandpass=False,
  1622                                                   reuse_spline=False,
  1623                                                   spline_opts=None,
  1624                                                   new_object=False,
  1625                                                   run_check=True,
  1626                                                   check_extra=True,
  1627                                                   run_check_acceptability=True,
  1628                                                   check_azza_domain: bool = True,
  1629                                               ):
  1630                                                   """
  1631                                                   Interpolate beam to given frequency, az & za locations or Healpix pixel centers.
  1632                                           
  1633                                                   Parameters
  1634                                                   ----------
  1635                                                   az_array : array_like of floats, optional
  1636                                                       Azimuth values to interpolate to in radians, either specifying the
  1637                                                       azimuth positions for every interpolation point or specifying the
  1638                                                       azimuth vector for a meshgrid if az_za_grid is True.
  1639                                                   za_array : array_like of floats, optional
  1640                                                       Zenith values to interpolate to in radians, either specifying the
  1641                                                       zenith positions for every interpolation point or specifying the
  1642                                                       zenith vector for a meshgrid if az_za_grid is True.
  1643                                                   az_za_grid : bool
  1644                                                       Option to treat the `az_array` and `za_array` as the input vectors
  1645                                                       for points on a mesh grid.
  1646                                                   healpix_nside : int, optional
  1647                                                       HEALPix nside parameter if interpolating to HEALPix pixels.
  1648                                                   healpix_inds : array_like of int, optional
  1649                                                       HEALPix indices to interpolate to. Defaults to all indices in the
  1650                                                       map if `healpix_nside` is set and `az_array` and `za_array` are None.
  1651                                                   freq_array : array_like of floats, optional
  1652                                                       Frequency values to interpolate to.
  1653                                                   freq_interp_tol : float
  1654                                                       Frequency distance tolerance [Hz] of nearest neighbors.
  1655                                                       If *all* elements in freq_array have nearest neighbor distances within
  1656                                                       the specified tolerance then return the beam at each nearest neighbor,
  1657                                                       otherwise interpolate the beam.
  1658                                                   polarizations : list of str
  1659                                                       polarizations to interpolate if beam_type is 'power'.
  1660                                                       Default is all polarizations in self.polarization_array.
  1661                                                   new_object : bool
  1662                                                       Option to return a new UVBeam object with the interpolated data,
  1663                                                       if possible. Note that this is only possible for Healpix pixels or
  1664                                                       if az_za_grid is True and `az_array` and `za_array` are evenly spaced
  1665                                                       or for frequency only interpolation.
  1666                                                   reuse_spline : bool
  1667                                                       Save the interpolation functions for reuse. Only applies for
  1668                                                       `az_za_simple` interpolation.
  1669                                                   spline_opts : dict
  1670                                                       Provide options to numpy.RectBivariateSpline. This includes spline
  1671                                                       order parameters `kx` and `ky`, and smoothing parameter `s`.
  1672                                                       Only applies for `az_za_simple` interpolation.
  1673                                                   run_check : bool
  1674                                                       Only used if new_object is True. Option to check for the existence
  1675                                                       and proper shapes of required parameters on the new object.
  1676                                                   check_extra : bool
  1677                                                       Only used if new_object is True. Option to check optional parameters
  1678                                                       as well as required ones on the new object.
  1679                                                   run_check_acceptability : bool
  1680                                                       Only used if new_object is True. Option to check acceptable range
  1681                                                       of the values of required parameters on the new object.
  1682                                                   check_azza_domain : bool
  1683                                                       Whether to check the domain of az/za to ensure that they are covered by the
  1684                                                       intrinsic data array. Checking them can be quite computationally expensive.
  1685                                                       Conversely, if the passed az/za are outside of the domain, they will be
  1686                                                       silently extrapolated and the behavior is not well-defined.
  1687                                           
  1688                                                   Returns
  1689                                                   -------
  1690                                                   array_like of float or complex or a UVBeam object
  1691                                                       Either an array of interpolated values or a UVBeam object if
  1692                                                       `new_object` is True. The shape of the interpolated data will be:
  1693                                                       (Naxes_vec, Nspws, Nfeeds or Npols, Nfreqs or freq_array.size if
  1694                                                       freq_array is passed, Npixels/(Naxis1, Naxis2) or az_array.size if
  1695                                                       az/za_arrays are passed)
  1696                                                   interp_basis_vector : array_like of float, optional
  1697                                                       an array of interpolated basis vectors (or self.basis_vector_array
  1698                                                       if az/za_arrays are not passed), shape: (Naxes_vec, Ncomponents_vec,
  1699                                                       Npixels/(Naxis1, Naxis2) or az_array.size if az/za_arrays are passed)
  1700                                                   interp_bandpass : array_like of float, optional
  1701                                                       The interpolated bandpass, only returned if `return_bandpass` is True.
  1702                                                       shape: (Nspws, freq_array.size)
  1703                                           
  1704                                                   """
  1705         4         25.0      6.2      0.0          if self.interpolation_function is None:
  1706                                                       raise ValueError("interpolation_function must be set on object first")
  1707         4         14.0      3.5      0.0          if self.freq_interp_kind is None:
  1708                                                       raise ValueError("freq_interp_kind must be set on object first")
  1709                                           
  1710         4          5.0      1.2      0.0          if new_object:
  1711         1          1.0      1.0      0.0              if not az_za_grid and az_array is not None:
  1712                                                           raise ValueError(
  1713                                                               "A new object can only be returned if "
  1714                                                               "az_za_grid is True or for Healpix pixels or "
  1715                                                               "for frequency only interpolation."
  1716                                                           )
  1717                                           
  1718         4          8.0      2.0      0.0          kind_use = self.freq_interp_kind
  1719         4          5.0      1.2      0.0          if freq_array is not None:
  1720                                                       # get frequency distances
  1721         4         50.0     12.5      0.0              freq_dists = np.abs(self.freq_array - freq_array.reshape(-1, 1))
  1722         4        180.0     45.0      0.0              nearest_dist = np.min(freq_dists, axis=1)
  1723         4        102.0     25.5      0.0              interp_bool = np.any(nearest_dist >= freq_interp_tol)
  1724                                           
  1725                                                       # use the beam at nearest neighbors if not interp_bool
  1726         4          6.0      1.5      0.0              if not interp_bool:
  1727         3          4.0      1.3      0.0                  kind_use = "nearest"
  1728                                           
  1729         4          4.0      1.0      0.0          if az_za_grid:
  1730                                                       az_array_use, za_array_use = np.meshgrid(az_array, za_array)
  1731                                                       az_array_use = az_array_use.flatten()
  1732                                                       za_array_use = za_array_use.flatten()
  1733                                                   else:
  1734         4        373.0     93.2      0.0              az_array_use = copy.copy(az_array)
  1735         4        335.0     83.8      0.0              za_array_use = copy.copy(za_array)
  1736                                           
  1737         4          5.0      1.2      0.0          if healpix_nside is not None or healpix_inds is not None:
  1738                                                       if healpix_nside is None:
  1739                                                           raise ValueError("healpix_nside must be set if healpix_inds is set.")
  1740                                                       if az_array is not None or za_array is not None:
  1741                                                           raise ValueError(
  1742                                                               "healpix_nside and healpix_inds can not be "
  1743                                                               "set if az_array or za_array is set."
  1744                                                           )
  1745                                                       try:
  1746                                                           from astropy_healpix import HEALPix
  1747                                                       except ImportError as e:  # pragma: no cover
  1748                                                           raise ImportError(
  1749                                                               "astropy_healpix is not installed but is "
  1750                                                               "required for healpix functionality. "
  1751                                                               'Install "astropy-healpix" using conda or pip.'
  1752                                                           ) from e
  1753                                           
  1754                                                       hp_obj = HEALPix(nside=healpix_nside)
  1755                                                       if healpix_inds is None:
  1756                                                           healpix_inds = np.arange(hp_obj.npix)
  1757                                           
  1758                                                       hpx_lon, hpx_lat = hp_obj.healpix_to_lonlat(healpix_inds)
  1759                                           
  1760                                                       za_array_use = (Angle(np.pi / 2, units.radian) - hpx_lat).radian
  1761                                                       az_array_use = hpx_lon.radian
  1762                                           
  1763         8         46.0      5.8      0.0          interp_func = self.interpolation_function_dict[self.interpolation_function][
  1764         4          4.0      1.0      0.0              "func"
  1765                                                   ]
  1766                                           
  1767         4          6.0      1.5      0.0          extra_keyword_dict = {}
  1768         4          6.0      1.5      0.0          if interp_func == "_interp_az_za_rect_spline":
  1769         4          6.0      1.5      0.0              extra_keyword_dict["reuse_spline"] = reuse_spline
  1770         4          4.0      1.0      0.0              extra_keyword_dict["spline_opts"] = spline_opts
  1771         4          5.0      1.2      0.0              extra_keyword_dict["check_azza_domain"] = check_azza_domain
  1772                                           
  1773        16   11517281.0 719830.1     96.9          interp_data, interp_basis_vector, interp_bandpass = getattr(self, interp_func)(
  1774         4          5.0      1.2      0.0              az_array_use,
  1775         4          4.0      1.0      0.0              za_array_use,
  1776         4          5.0      1.2      0.0              freq_array,
  1777         4          5.0      1.2      0.0              freq_interp_kind=kind_use,
  1778         4          4.0      1.0      0.0              polarizations=polarizations,
  1779         4          4.0      1.0      0.0              **extra_keyword_dict,
  1780                                                   )
  1781                                           
  1782                                                   # return just the interpolated arrays
  1783         4         24.0      6.0      0.0          if not new_object:
  1784         3          4.0      1.3      0.0              if return_bandpass:
  1785                                                           return interp_data, interp_basis_vector, interp_bandpass
  1786                                                       else:
  1787         3          3.0      1.0      0.0                  return interp_data, interp_basis_vector
  1788                                           
  1789                                                   # return a new UVBeam object with interpolated data
  1790                                                   else:
  1791                                                       # make a new object
  1792         1     366983.0 366983.0      3.1              new_uvb = self.copy()
  1793                                           
  1794         1          2.0      2.0      0.0              history_update_string = " Interpolated"
  1795         1          1.0      1.0      0.0              if freq_array is not None:
  1796         1          2.0      2.0      0.0                  history_update_string += " in frequency"
  1797         1          5.0      5.0      0.0                  new_uvb.Nfreqs = freq_array.size
  1798         1         10.0     10.0      0.0                  new_uvb.freq_array = freq_array.reshape(1, -1)
  1799         1          3.0      3.0      0.0                  new_uvb.bandpass_array = interp_bandpass
  1800         1          3.0      3.0      0.0                  new_uvb.freq_interp_kind = kind_use
  1801                                           
  1802         1          2.0      2.0      0.0              if az_array is not None:
  1803                                                           if freq_array is not None:
  1804                                                               history_update_string += " and"
  1805                                                           if new_uvb.pixel_coordinate_system != "az_za":
  1806                                                               input_desc = self.coordinate_system_dict[
  1807                                                                   new_uvb.pixel_coordinate_system
  1808                                                               ]["description"]
  1809                                                               output_desc = self.coordinate_system_dict["az_za"]["description"]
  1810                                                               history_update_string += (
  1811                                                                   " from " + input_desc + " to " + output_desc
  1812                                                               )
  1813                                                               new_uvb.pixel_coordinate_system = "az_za"
  1814                                                               new_uvb.Npixels = None
  1815                                                               new_uvb.pixel_array = None
  1816                                                               new_uvb.nside = None
  1817                                                               new_uvb.ordering = None
  1818                                                           else:
  1819                                                               history_update_string += " to a new azimuth/zenith angle grid"
  1820                                           
  1821                                                           interp_data = interp_data.reshape(
  1822                                                               interp_data.shape[:-1] + (za_array.size, az_array.size)
  1823                                                           )
  1824                                                           if interp_basis_vector is not None:
  1825                                                               interp_basis_vector = interp_basis_vector.reshape(
  1826                                                                   interp_basis_vector.shape[:-1] + (za_array.size, az_array.size)
  1827                                                               )
  1828                                           
  1829                                                           new_uvb.axis1_array = az_array
  1830                                                           new_uvb.axis2_array = za_array
  1831                                                           new_uvb.Naxes1 = new_uvb.axis1_array.size
  1832                                                           new_uvb.Naxes2 = new_uvb.axis2_array.size
  1833                                           
  1834         1          1.0      1.0      0.0              elif healpix_nside is not None:
  1835                                                           if freq_array is not None:
  1836                                                               history_update_string += " and"
  1837                                                           if new_uvb.pixel_coordinate_system != "healpix":
  1838                                                               input_desc = self.coordinate_system_dict[
  1839                                                                   new_uvb.pixel_coordinate_system
  1840                                                               ]["description"]
  1841                                                               output_desc = self.coordinate_system_dict["healpix"]["description"]
  1842                                                               history_update_string += (
  1843                                                                   " from " + input_desc + " to " + output_desc
  1844                                                               )
  1845                                                               new_uvb.pixel_coordinate_system = "healpix"
  1846                                                               new_uvb.Naxes1 = None
  1847                                                               new_uvb.axis1_array = None
  1848                                                               new_uvb.Naxes2 = None
  1849                                                               new_uvb.axis2_array = None
  1850                                                           else:
  1851                                                               history_update_string += " to a new healpix grid"
  1852                                           
  1853                                                           new_uvb.pixel_array = healpix_inds
  1854                                                           new_uvb.Npixels = new_uvb.pixel_array.size
  1855                                                           new_uvb.nside = healpix_nside
  1856                                                           new_uvb.ordering = "ring"
  1857                                           
  1858         2          3.0      1.5      0.0              history_update_string += (
  1859         2          2.0      1.0      0.0                  " using pyuvdata with interpolation_function = "
  1860         1          2.0      2.0      0.0                  + new_uvb.interpolation_function
  1861                                                       )
  1862         1          1.0      1.0      0.0              if freq_array is not None:
  1863         2          3.0      1.5      0.0                  history_update_string += (
  1864         1          1.0      1.0      0.0                      " and freq_interp_kind = " + new_uvb.freq_interp_kind
  1865                                                           )
  1866         1          2.0      2.0      0.0              history_update_string += "."
  1867         1          3.0      3.0      0.0              new_uvb.history = new_uvb.history + history_update_string
  1868         1       1791.0   1791.0      0.0              new_uvb.data_array = interp_data
  1869         1          7.0      7.0      0.0              if new_uvb.basis_vector_array is not None:
  1870         1          5.0      5.0      0.0                  new_uvb.basis_vector_array = interp_basis_vector
  1871                                           
  1872         1          2.0      2.0      0.0              if hasattr(new_uvb, "saved_interp_functions"):
  1873                                                           delattr(new_uvb, "saved_interp_functions")
  1874                                           
  1875         1         47.0     47.0      0.0              new_uvb._set_cs_params()
  1876         1          1.0      1.0      0.0              if run_check:
  1877                                                           new_uvb.check(
  1878                                                               check_extra=check_extra,
  1879                                                               run_check_acceptability=run_check_acceptability,
  1880                                                           )
  1881         1          1.0      1.0      0.0              return new_uvb

Total time: 11.1669 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/vis_cpu/cpu.py
Function: _wrangle_beams at line 26

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    26                                           def _wrangle_beams(
    27                                               beam_idx: np.ndarray,
    28                                               beam_list: list[UVBeam],
    29                                               polarized: bool,
    30                                               nant: int,
    31                                               freq: float,
    32                                           ) -> tuple[list[UVBeam], int, np.ndarray]:
    33                                               """Perform all the operations and checks on the input beams.
    34                                           
    35                                               Checks that the beam indices match the number of antennas, pre-interpolates to the
    36                                               given frequency, and checks that the beam type is appropriate for the given
    37                                               polarization
    38                                           
    39                                               Parameters
    40                                               ----------
    41                                               beam_idx
    42                                                   Index of the beam to use for each antenna.
    43                                               beam_list
    44                                                   List of unique beams.
    45                                               polarized
    46                                                   Whether to use beam polarization
    47                                               nant
    48                                                   Number of antennas
    49                                               freq
    50                                                   Frequency to interpolate beam to.
    51                                               """
    52                                               # Get the number of unique beams
    53         1          1.0      1.0      0.0      nbeam = len(beam_list)
    54                                           
    55                                               # Check the beam indices
    56         1          1.0      1.0      0.0      if beam_idx is None:
    57                                                   if nbeam == 1:
    58                                                       beam_idx = np.zeros(nant, dtype=int)
    59                                                   elif nbeam == nant:
    60                                                       beam_idx = np.arange(nant, dtype=int)
    61                                                   else:
    62                                                       raise ValueError(
    63                                                           "If number of beams provided is not 1 or nant, beam_idx must be provided."
    64                                                       )
    65                                               else:
    66         1          2.0      2.0      0.0          assert beam_idx.shape == (nant,), "beam_idx must be length nant"
    67         2        416.0    208.0      0.0          assert all(
    68         1          1.0      1.0      0.0              0 <= i < nbeam for i in beam_idx
    69                                                   ), "beam_idx contains indices greater than the number of beams"
    70                                           
    71                                               # make sure we interpolate to the right frequency first.
    72         1         10.0     10.0      0.0      print("BEAM LIST SHAPE: ", len(beam_list))
    73                                               
    74         2   11166435.0 5583217.5    100.0      beam_list = [
    75                                                   bm.interp(freq_array=np.array([freq]), new_object=True, run_check=False)
    76                                                   if isinstance(bm, UVBeam)
    77                                                   else bm
    78         1          1.0      1.0      0.0          for bm in beam_list
    79                                               ]
    80                                           
    81         1          7.0      7.0      0.0      if polarized and any(b.beam_type != "efield" for b in beam_list):
    82                                                   raise ValueError("beam type must be efield if using polarized=True")
    83         1          0.0      0.0      0.0      elif not polarized and any(
    84                                                   (
    85                                                       b.beam_type != "power"
    86                                                       or getattr(b, "Npols", 1) > 1
    87                                                       or b.polarization_array[0] not in [-5, -6]
    88                                                   )
    89                                                   for b in beam_list
    90                                               ):
    91                                                   raise ValueError(
    92                                                       "beam type must be power and have only one pol (either xx or yy) if polarized=False"
    93                                                   )
    94                                           
    95         1          1.0      1.0      0.0      return beam_list, nbeam, beam_idx

Total time: 0.747986 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/vis_cpu/cpu.py
Function: _evaluate_beam_cpu at line 98

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    98                                           def _evaluate_beam_cpu(
    99                                               A_s: np.ndarray,
   100                                               beam_list: list[UVBeam],
   101                                               tx: np.ndarray,
   102                                               ty: np.ndarray,
   103                                               polarized: bool,
   104                                               freq: float,
   105                                               spline_opts: dict | None = None,
   106                                           ):
   107                                               """Evaluate the beam on the CPU.
   108                                           
   109                                               This function will either interpolate the beam to the given coordinates tx, ty,
   110                                               or evaluate the beam there if it is an analytic beam.
   111                                           
   112                                               Parameters
   113                                               ----------
   114                                               A_s
   115                                                   Array of shape (nax, nfeed, nbeam, nsrcs_up) that will be filled with beam
   116                                                   values.
   117                                               beam_list
   118                                                   List of unique beams.
   119                                               tx, ty
   120                                                   Coordinates to evaluate the beam at, in sin-projection.
   121                                               polarized
   122                                                   Whether to use beam polarization.
   123                                               freq
   124                                                   Frequency to interpolate beam to.
   125                                               spline_opts
   126                                                   Extra options to pass to the RectBivariateSpline class when interpolating.
   127                                               """
   128                                               # Primary beam pattern using direct interpolation of UVBeam object
   129         3      18723.0   6241.0      2.5      az, za = conversions.enu_to_az_za(enu_e=tx, enu_n=ty, orientation="uvbeam")
   130         3         65.0     21.7      0.0      print(f"ABOUT TO DO {len(beam_list)} of these!")
   131         6         14.0      2.3      0.0      for i, bm in enumerate(beam_list):
   132         3          1.0      0.3      0.0          kw = (
   133         6          6.0      1.0      0.0              {
   134         3          1.0      0.3      0.0                  "reuse_spline": True,
   135         3          1.0      0.3      0.0                  "check_azza_domain": False,
   136         3          2.0      0.7      0.0                  "spline_opts": spline_opts,
   137                                                       }
   138         3          4.0      1.3      0.0              if isinstance(bm, UVBeam)
   139                                                       else {}
   140                                                   )
   141                                           
   142        12     721476.0  60123.0     96.5          interp_beam = bm.interp(
   143         3          3.0      1.0      0.0              az_array=az,
   144         3          2.0      0.7      0.0              za_array=za,
   145         3         87.0     29.0      0.0              freq_array=np.atleast_1d(freq),
   146         3          2.0      0.7      0.0              **kw,
   147         3          3.0      1.0      0.0          )[0]
   148                                           
   149         3          2.0      0.7      0.0          if polarized:
   150         3          7.0      2.3      0.0              interp_beam = interp_beam[:, 0, :, 0, :]
   151                                                   else:
   152                                                       # Here we have already asserted that the beam is a power beam and
   153                                                       # has only one polarization, so we just evaluate that one.
   154                                                       interp_beam = np.sqrt(interp_beam[0, 0, 0, 0, :])
   155                                           
   156         3       5701.0   1900.3      0.8          A_s[:, :, i] = interp_beam
   157                                           
   158                                                   # Check for invalid beam values
   159         3       1847.0    615.7      0.2          sm = np.sum(A_s)
   160         6         37.0      6.2      0.0          if np.isinf(sm) or np.isnan(
   161         3          1.0      0.3      0.0              sm
   162                                                   ):  # np.any(np.isinf(A_s)) or np.any(np.isnan(A_s)):
   163                                                       raise ValueError("Beam interpolation resulted in an invalid value")
   164                                           
   165         3          1.0      0.3      0.0      return A_s

Total time: 22.0224 s
File: /ilifu/astro/projects/hera/smurray/miniconda3/envs/h4c/lib/python3.10/site-packages/vis_cpu/cpu.py
Function: vis_cpu at line 190

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   190                                           @profile
   191                                           def vis_cpu(
   192                                               *,
   193                                               antpos: np.ndarray,
   194                                               freq: float,
   195                                               eq2tops: np.ndarray,
   196                                               crd_eq: np.ndarray,
   197                                               I_sky: np.ndarray,
   198                                               beam_list: Sequence[UVBeam | Callable] | None,
   199                                               precision: int = 1,
   200                                               polarized: bool = False,
   201                                               beam_idx: np.ndarray | None = None,
   202                                               beam_spline_opts: dict | None = None,
   203                                           ):
   204                                               """
   205                                               Calculate visibility from an input intensity map and beam model.
   206                                           
   207                                               Parameters
   208                                               ----------
   209                                               antpos : array_like
   210                                                   Antenna position array. Shape=(NANT, 3).
   211                                               freq : float
   212                                                   Frequency to evaluate the visibilities at [GHz].
   213                                               eq2tops : array_like
   214                                                   Set of 3x3 transformation matrices to rotate the RA and Dec
   215                                                   cosines in an ECI coordinate system (see `crd_eq`) to
   216                                                   topocentric ENU (East-North-Up) unit vectors at each
   217                                                   time/LST/hour angle in the dataset.
   218                                                   Shape=(NTIMES, 3, 3).
   219                                               crd_eq : array_like
   220                                                   Cartesian unit vectors of sources in an ECI (Earth Centered
   221                                                   Inertial) system, which has the Earth's center of mass at
   222                                                   the origin, and is fixed with respect to the distant stars.
   223                                                   The components of the ECI vector for each source are:
   224                                                   (cos(RA) cos(Dec), sin(RA) cos(Dec), sin(Dec)).
   225                                                   Shape=(3, NSRCS).
   226                                               I_sky : array_like
   227                                                   Intensity distribution of sources/pixels on the sky, assuming intensity
   228                                                   (Stokes I) only. The Stokes I intensity will be split equally between
   229                                                   the two linear polarization channels, resulting in a factor of 0.5 from
   230                                                   the value inputted here. This is done even if only one polarization
   231                                                   channel is simulated.
   232                                                   Shape=(NSRCS,).
   233                                               beam_list : list of UVBeam, optional
   234                                                   If specified, evaluate primary beam values directly using UVBeam
   235                                                   objects instead of using pixelized beam maps. Only one of ``bm_cube`` and
   236                                                   ``beam_list`` should be provided.Note that if `polarized` is True,
   237                                                   these beams must be efield beams, and conversely if `polarized` is False they
   238                                                   must be power beams with a single polarization (either XX or YY).
   239                                               precision : int, optional
   240                                                   Which precision level to use for floats and complex numbers.
   241                                                   Allowed values:
   242                                                   - 1: float32, complex64
   243                                                   - 2: float64, complex128
   244                                               polarized : bool, optional
   245                                                   Whether to simulate a full polarized response in terms of nn, ne, en,
   246                                                   ee visibilities. See Eq. 6 of Kohn+ (arXiv:1802.04151) for notation.
   247                                                   Default: False.
   248                                               beam_idx
   249                                                   Optional length-NANT array specifying a beam index for each antenna.
   250                                                   By default, either a single beam is assumed to apply to all antennas or
   251                                                   each antenna gets its own beam.
   252                                           
   253                                               Returns
   254                                               -------
   255                                               vis : array_like
   256                                                   Simulated visibilities. If `polarized = True`, the output will have
   257                                                   shape (NTIMES, NFEED, NFEED, NANTS, NANTS), otherwise it will have
   258                                                   shape (NTIMES, NANTS, NANTS).
   259                                               """
   260         2         12.0      6.0      0.0      nax, nfeed, nant, ntimes = _validate_inputs(
   261         1          1.0      1.0      0.0          precision, polarized, antpos, eq2tops, crd_eq, I_sky
   262                                               )
   263                                           
   264         1          1.0      1.0      0.0      if precision == 1:
   265                                                   real_dtype = np.float32
   266                                                   complex_dtype = np.complex64
   267                                               else:
   268         1          1.0      1.0      0.0          real_dtype = np.float64
   269         1          1.0      1.0      0.0          complex_dtype = np.complex128
   270                                           
   271         2   11166948.0 5583474.0     50.7      beam_list, nbeam, beam_idx = _wrangle_beams(
   272         1          1.0      1.0      0.0          beam_idx, beam_list, polarized, nant, freq
   273                                               )
   274                                           
   275                                               # Intensity distribution (sqrt) and antenna positions. Does not support
   276                                               # negative sky. Factor of 0.5 accounts for splitting Stokes I between
   277                                               # polarization channels
   278         1        819.0    819.0      0.0      Isqrt = np.sqrt(0.5 * I_sky).astype(real_dtype)
   279         1          6.0      6.0      0.0      antpos = antpos.astype(real_dtype)
   280                                           
   281         1          9.0      9.0      0.0      ang_freq = real_dtype(2.0 * np.pi * freq)
   282                                           
   283                                               # Zero arrays: beam pattern, visibilities, delays, complex voltages
   284         1        246.0    246.0      0.0      vis = np.zeros((ntimes, nfeed * nant, nfeed * nant), dtype=complex_dtype)
   285         1       1126.0   1126.0      0.0      crd_eq = crd_eq.astype(real_dtype)
   286                                           
   287                                               # Loop over time samples
   288         4         35.0      8.8      0.0      for t, eq2top in enumerate(eq2tops.astype(real_dtype)):
   289                                                   # Dot product converts ECI cosines (i.e. from RA and Dec) into ENU
   290                                                   # (topocentric) cosines, with (tx, ty, tz) = (e, n, u) components
   291                                                   # relative to the center of the array
   292         3       5463.0   1821.0      0.0          tx, ty, tz = crd_top = np.dot(eq2top, crd_eq)
   293         3        317.0    105.7      0.0          above_horizon = tz > 0
   294         3       3616.0   1205.3      0.0          tx = tx[above_horizon]
   295         3       3309.0   1103.0      0.0          ty = ty[above_horizon]
   296         3         10.0      3.3      0.0          nsrcs_up = len(tx)
   297         3       3367.0   1122.3      0.0          isqrt = Isqrt[above_horizon]
   298                                           
   299         3       2330.0    776.7      0.0          A_s = np.zeros((nax, nfeed, nbeam, nsrcs_up), dtype=complex_dtype)
   300                                           
   301         6     748128.0 124688.0      3.4          _evaluate_beam_cpu(
   302         3          3.0      1.0      0.0              A_s,
   303         3          3.0      1.0      0.0              beam_list,
   304         3          3.0      1.0      0.0              tx,
   305         3          3.0      1.0      0.0              ty,
   306         3          3.0      1.0      0.0              polarized,
   307         3          2.0      0.7      0.0              freq,
   308         3          2.0      0.7      0.0              spline_opts=beam_spline_opts,
   309                                                   )
   310         3         13.0      4.3      0.0          A_s = A_s.transpose((1, 2, 0, 3))  # Now (Nfeed, Nbeam, Nax, Nsrc)
   311                                           
   312         3         61.0     20.3      0.0          _log_array("beam", A_s)
   313                                           
   314                                                   # Calculate delays, where tau = (b * s) / c
   315         3     161354.0  53784.7      0.7          tau = np.dot(antpos / c.value, crd_top[:, above_horizon])
   316         3         54.0     18.0      0.0          _log_array("tau", tau)
   317                                           
   318         6    5103144.0 850524.0     23.2          v = _get_antenna_vis(
   319         3          5.0      1.7      0.0              A_s, ang_freq, tau, isqrt, beam_idx, nfeed, nant, nax, nsrcs_up
   320                                                   )
   321         3         54.0     18.0      0.0          _log_array("vant", v)
   322                                           
   323                                                   # Compute visibilities using product of complex voltages (upper triangle).
   324         3    4821840.0 1607280.0     21.9          vis[t] = v.conj().dot(v.T)
   325         3         57.0     19.0      0.0          _log_array("vis", vis[t])
   326                                           
   327         1          5.0      5.0      0.0      vis.shape = (ntimes, nfeed, nant, nfeed, nant)
   328                                           
   329                                               # Return visibilities with or without multiple polarization channels
   330         1          4.0      4.0      0.0      return vis.transpose((0, 1, 3, 2, 4)) if polarized else vis[:, 0, :, 0, :]

